Since commit [1], libcxx assumes that gcc has builtin `__is_nothrow_assignable` and 
`__is_nothrow_constructible`, but they don't exists in gcc-9 and gcc-10.

[1]: https://github.com/llvm/llvm-project/commit/a13822b35d11cb6afa759fa0672fbc0b6ef295d0

--- a/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_assignable.h
+++ b/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_assignable.h
@@ -18,13 +18,39 @@
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if __has_builtin(__is_nothrow_assignable)
+
 template <class _Tp, class _Arg>
 struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
     : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
 
+#else
+
+template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;
+
+template <class _Tp, class _Arg>
+struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>
+    : public false_type
+{
+};
+
+template <class _Tp, class _Arg>
+struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
+    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Arg>()) >
+{
+};
+
+template <class _Tp, class _Arg>
+struct _LIBCPP_TEMPLATE_VIS is_nothrow_assignable
+    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>
+{
+};
+
+#endif // __has_builtin(__is_nothrow_assignable)
+
 #if _LIBCPP_STD_VER > 14
 template <class _Tp, class _Arg>
-inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_Tp, _Arg);
+inline constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Tp, _Arg>::value;
 #endif
 
 _LIBCPP_END_NAMESPACE_STD
--- a/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h
+++ b/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_copy_assignable.h
@@ -20,6 +20,8 @@
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if __has_builtin(__is_nothrow_assignable)
+
 template <class _Tp>
 struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable
     : public integral_constant<
@@ -28,6 +30,14 @@
               __add_lvalue_reference_t<_Tp>,
               __add_lvalue_reference_t<typename add_const<_Tp>::type>)> {};
 
+#else
+
+template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_copy_assignable
+    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
+                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};
+
+#endif
+
 #if _LIBCPP_STD_VER > 14
 template <class _Tp>
 inline constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Tp>::value;
--- a/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h
+++ b/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_default_constructible.h
@@ -11,6 +11,7 @@
 
 #include <__config>
 #include <__type_traits/integral_constant.h>
+#include <__type_traits/is_nothrow_constructible.h>
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #  pragma GCC system_header
@@ -18,13 +19,23 @@
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if __has_builtin(__is_nothrow_constructible)
+
 template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible
     : public integral_constant<bool, __is_nothrow_constructible(_Tp)>
     {};
 
+#else
+
+template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_default_constructible
+    : public is_nothrow_constructible<_Tp>
+    {};
+
+#endif
+
 #if _LIBCPP_STD_VER > 14
 template <class _Tp>
-inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Tp);
+inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Tp>::value;
 #endif
 
 _LIBCPP_END_NAMESPACE_STD
--- a/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h
+++ b/toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/include/c++/v1/__type_traits/is_nothrow_move_assignable.h
@@ -13,6 +13,7 @@
 #include <__type_traits/add_lvalue_reference.h>
 #include <__type_traits/add_rvalue_reference.h>
 #include <__type_traits/integral_constant.h>
+#include <__type_traits/is_nothrow_assignable.h>
 
 #if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
 #  pragma GCC system_header
@@ -20,6 +21,8 @@
 
 _LIBCPP_BEGIN_NAMESPACE_STD
 
+#if __has_builtin(__is_nothrow_assignable)
+
 template <class _Tp>
 struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable
     : public integral_constant<
@@ -27,6 +30,15 @@
           __is_nothrow_assignable(__add_lvalue_reference_t<_Tp>, __add_rvalue_reference_t<_Tp>)> {
 };
 
+#else
+
+template <class _Tp> struct _LIBCPP_TEMPLATE_VIS is_nothrow_move_assignable
+    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
+                                     typename add_rvalue_reference<_Tp>::type>
+    {};
+
+#endif
+
 #if _LIBCPP_STD_VER > 14
 template <class _Tp>
 inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Tp>::value;
